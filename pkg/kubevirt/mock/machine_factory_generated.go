// Code generated by MockGen. DO NOT EDIT.
// Source: ./machine_factory.go

// Package mock_kubevirt is a generated GoMock package.
package mock_kubevirt

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
	client "sigs.k8s.io/controller-runtime/pkg/client"

	context0 "sigs.k8s.io/cluster-api-provider-kubevirt/pkg/context"
	kubevirt "sigs.k8s.io/cluster-api-provider-kubevirt/pkg/kubevirt"
	ssh "sigs.k8s.io/cluster-api-provider-kubevirt/pkg/ssh"
	workloadcluster "sigs.k8s.io/cluster-api-provider-kubevirt/pkg/workloadcluster"
)

// MockMachineInterface is a mock of MachineInterface interface.
type MockMachineInterface struct {
	ctrl     *gomock.Controller
	recorder *MockMachineInterfaceMockRecorder
}

// MockMachineInterfaceMockRecorder is the mock recorder for MockMachineInterface.
type MockMachineInterfaceMockRecorder struct {
	mock *MockMachineInterface
}

// NewMockMachineInterface creates a new mock instance.
func NewMockMachineInterface(ctrl *gomock.Controller) *MockMachineInterface {
	mock := &MockMachineInterface{ctrl: ctrl}
	mock.recorder = &MockMachineInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMachineInterface) EXPECT() *MockMachineInterfaceMockRecorder {
	return m.recorder
}

// Address mocks base method.
func (m *MockMachineInterface) Address() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Address")
	ret0, _ := ret[0].(string)
	return ret0
}

// Address indicates an expected call of Address.
func (mr *MockMachineInterfaceMockRecorder) Address() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Address", reflect.TypeOf((*MockMachineInterface)(nil).Address))
}

// Create mocks base method.
func (m *MockMachineInterface) Create(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockMachineInterfaceMockRecorder) Create(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockMachineInterface)(nil).Create), ctx)
}

// Delete mocks base method.
func (m *MockMachineInterface) Delete() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete")
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockMachineInterfaceMockRecorder) Delete() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockMachineInterface)(nil).Delete))
}

// DrainNodeIfNeeded mocks base method.
func (m *MockMachineInterface) DrainNodeIfNeeded(arg0 workloadcluster.WorkloadCluster) (time.Duration, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DrainNodeIfNeeded", arg0)
	ret0, _ := ret[0].(time.Duration)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DrainNodeIfNeeded indicates an expected call of DrainNodeIfNeeded.
func (mr *MockMachineInterfaceMockRecorder) DrainNodeIfNeeded(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DrainNodeIfNeeded", reflect.TypeOf((*MockMachineInterface)(nil).DrainNodeIfNeeded), arg0)
}

// Exists mocks base method.
func (m *MockMachineInterface) Exists() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exists indicates an expected call of Exists.
func (mr *MockMachineInterfaceMockRecorder) Exists() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockMachineInterface)(nil).Exists))
}

// GenerateProviderID mocks base method.
func (m *MockMachineInterface) GenerateProviderID() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateProviderID")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GenerateProviderID indicates an expected call of GenerateProviderID.
func (mr *MockMachineInterfaceMockRecorder) GenerateProviderID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateProviderID", reflect.TypeOf((*MockMachineInterface)(nil).GenerateProviderID))
}

// GetVMNotReadyReason mocks base method.
func (m *MockMachineInterface) GetVMNotReadyReason() (string, string) {
	return "", ""
}

// IsBootstrapped mocks base method.
func (m *MockMachineInterface) IsBootstrapped() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsBootstrapped")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsBootstrapped indicates an expected call of IsBootstrapped.
func (mr *MockMachineInterfaceMockRecorder) IsBootstrapped() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsBootstrapped", reflect.TypeOf((*MockMachineInterface)(nil).IsBootstrapped))
}

// IsLiveMigratable mocks base method.
func (m *MockMachineInterface) IsLiveMigratable() (bool, string, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLiveMigratable")
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(string)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// IsLiveMigratable indicates an expected call of IsLiveMigratable.
func (mr *MockMachineInterfaceMockRecorder) IsLiveMigratable() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLiveMigratable", reflect.TypeOf((*MockMachineInterface)(nil).IsLiveMigratable))
}

// IsReady mocks base method.
func (m *MockMachineInterface) IsReady() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsReady")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsReady indicates an expected call of IsReady.
func (mr *MockMachineInterfaceMockRecorder) IsReady() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsReady", reflect.TypeOf((*MockMachineInterface)(nil).IsReady))
}

// IsTerminal mocks base method.
func (m *MockMachineInterface) IsTerminal() (bool, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsTerminal")
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// IsTerminal indicates an expected call of IsTerminal.
func (mr *MockMachineInterfaceMockRecorder) IsTerminal() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsTerminal", reflect.TypeOf((*MockMachineInterface)(nil).IsTerminal))
}

// SupportsCheckingIsBootstrapped mocks base method.
func (m *MockMachineInterface) SupportsCheckingIsBootstrapped() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SupportsCheckingIsBootstrapped")
	ret0, _ := ret[0].(bool)
	return ret0
}

// SupportsCheckingIsBootstrapped indicates an expected call of SupportsCheckingIsBootstrapped.
func (mr *MockMachineInterfaceMockRecorder) SupportsCheckingIsBootstrapped() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SupportsCheckingIsBootstrapped", reflect.TypeOf((*MockMachineInterface)(nil).SupportsCheckingIsBootstrapped))
}

// MockMachineFactory is a mock of MachineFactory interface.
type MockMachineFactory struct {
	ctrl     *gomock.Controller
	recorder *MockMachineFactoryMockRecorder
}

// MockMachineFactoryMockRecorder is the mock recorder for MockMachineFactory.
type MockMachineFactoryMockRecorder struct {
	mock *MockMachineFactory
}

// NewMockMachineFactory creates a new mock instance.
func NewMockMachineFactory(ctrl *gomock.Controller) *MockMachineFactory {
	mock := &MockMachineFactory{ctrl: ctrl}
	mock.recorder = &MockMachineFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMachineFactory) EXPECT() *MockMachineFactoryMockRecorder {
	return m.recorder
}

// NewMachine mocks base method.
func (m *MockMachineFactory) NewMachine(ctx *context0.MachineContext, client client.Client, namespace string, sshKeys *ssh.ClusterNodeSshKeys) (kubevirt.MachineInterface, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewMachine", ctx, client, namespace, sshKeys)
	ret0, _ := ret[0].(kubevirt.MachineInterface)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewMachine indicates an expected call of NewMachine.
func (mr *MockMachineFactoryMockRecorder) NewMachine(ctx, client, namespace, sshKeys interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewMachine", reflect.TypeOf((*MockMachineFactory)(nil).NewMachine), ctx, client, namespace, sshKeys)
}
